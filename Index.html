<html>
	<head>
		<meta charset="UTF-8">
		<link rel="stylesheet" href="style/style.css">
		<script src="js/pixi.min.js"></script>
		<script type="text/javascript">
			let app;
			let graphics;
			let renderer;
			let flipped = false;
			let strokes = [];
			let strokeCount = 0;

			let currentColor = '0x000000';
			let currentSize = 3;
			var isDrawing = false;
			var x = 0;
			var y = 0;
			var oldx = 0;
			var oldy = 0;
			var count = 0;
			var eraserOn = false;
			
			// Make the redraw button
			const redrawButton = PIXI.Sprite.from('assets/button.png');
			redrawButton.anchor.set(0.5);
			redrawButton.x = 40;
			redrawButton.y = 20;
			redrawButton.interactive = true;
			redrawButton.buttonMode = true;
			redrawButton.on('pointerdown', redraw);

			window.onload = function(){
				
				var canvasContainer = document.getElementById("areaCanvasContainer");
				//Create a Pixi Application
				app = new PIXI.Application({ 
					width: 600,
					height: 500,
					antialias: false,
					transparent: false,
					resolution: 1,
					forceCanvas: false,
					backgroundColor: 0xFFFFFF
				});
				canvasContainer.appendChild(app.view);
				
				//app.view.addEventListener("touchstart", function(e) {    e.preventDefault();},{passive: false});
				//app.view.addEventListener("touchmove", function(e) {    e.preventDefault();},{passive: false});
				
				graphics = new PIXI.Graphics();

				graphics.interactive = true;
				graphics.buttonMode = true;
				
				graphics.clear();
				
				graphics.moveTo(0,0);
				
				app.renderer.plugins.interaction.on("pointerdown", mousedown);
				app.renderer.plugins.interaction.on("pointermove", mousemove);
				app.renderer.plugins.interaction.on("pointerup", mouseup);
				app.renderer.plugins.interaction.on("pointerupoutside", mouseup);

				graphics.lineStyle(3, 0x000000,1,0.5,false);
				
				app.stage.addChild(graphics);
				app.stage.addChild(redrawButton);

				//setInterval(drawUpdate, 1000/100);

				let tick = 0;
				let tock = 0;
				app.ticker.add((delta) => 
				{
					tick += delta;
					tock += delta;
					if (tick > 1)
					{
						graphics.lineStyle(currentSize, currentColor,1,0.5,false);
						drawUpdate();
						graphics.closePath();
						tick = 0;
					}
					// if (tock > 10)
					// {
					// 	currentColor = addHexColor(currentColor, 000010);
					// 	tock = 0;
					// }
				})
			}
			
			function addHexColor(c1, c2) 
			{
				var hexStr = (parseInt(c1, 16) + parseInt(c2, 16)).toString(16);
				while (hexStr.length < 6) { hexStr = '0' + hexStr; } // Zero pad.
				return hexStr;
			}

			function mousedown(e) {
				console.log(currentColor);
				x = e.data.global.x;
				y = e.data.global.y;
				oldx = x;
				oldy = y;
				isDrawing = true;
			}
			
			function mousemove(e) {
				if (isDrawing === true) {
					if(Math.abs(x - e.data.global.x) > 2 || Math.abs(y - e.data.global.y ) > 2 ){
						x = e.data.global.x;
						y = e.data.global.y;
					}
				}
			}
			
			function mouseup(e) {
				if (isDrawing === true) {
					//drawLine(x, y, e.data.global.x, e.data.global.y);
					isDrawing = false;
				}
				strokes.push(strokeCount);
				strokeCount = 0;
				flipped = !flipped;
			}
			
			function drawLine(x1, y1, x2, y2) 
			{
				graphics.moveTo(x1, y1);
				graphics.lineTo(x2, y2);
			}

			function drawUpdate(){
				if(isDrawing){
					if(!(x === oldx && y === oldy)){
						graphics.moveTo(oldx, oldy);
						graphics.lineTo(x, y);
						oldx = x;
						oldy = y;
						redraw();
						strokeCount ++;
					}
				}
			}

			function redraw()
			{
				let lines = [];
				graphics.geometry.graphicsData.forEach(element => {
					lines.push(element);
				});

				// if (flipped)
				// {
				// 	lines.reverse();
				// 	flipped = !flipped;
				// }

				graphics.geometry.clear();

				lines.forEach(line => 
				{
					if (line.points.length == 4)
					{
						let p = line.points;
						graphics.lineStyle(3, line.lineStyle.color,1,0.5,false);
						drawLine(p[0], p[1], p[2], p[3]);
					}
				});
			}

			function undo()
			{
				strokes.pop();
				let trimmed = graphics.geometry.graphicsData.slice(strokes.pop());
				console.log(trimmed);
				graphics.geometry.graphicsData = trimmed;
				redraw();
			}

			function drawTest() 
			{
				let px = 0;
				let py = 0;
				for (let x = 5; x < app.renderer.screen.width; x = x + 50) 
				{
					graphics.moveTo(x, y);
					for (let y = 5; y < app.renderer.screen.height; y = y + 10)
					{
						let ty = y + (Math.random() * 40);
						let tx = x + (Math.random() * 40);
						drawLine(px, py, tx, ty);
						py = ty;
						px = tx;
					}
				}
				
			}

			function clearCanvas(){
				graphics.geometry.clear();
			}

			function toggleEraser(){
				if(eraserOn){
					currentColor = '0x000000';
					eraserOn = false;
				}
				else{
					currentColor = '0x4287f5';
					eraserOn = true;
				}
			}

		</script>
	</head>
	
	<body>
		<div id="areaMain">
			<h1>DrawV</h1>
			<div id="areaCanvasContainer">
				<!--<canvas id="canvasDraw" width="600" height="500" />-->
			</div>
			<div id="areaControls">
				<button onclick="clearCanvas()">Clear</button>
				<button id="btnEraser" onclick="toggleEraser()">Eraser</button>
				<button id="btnUndo" onclick="undo()">Undo</button>
			</div>
		</div>
	</body>
</html>